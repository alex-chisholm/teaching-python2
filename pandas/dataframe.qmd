# DataFrame {.unnumbered}

{{< include _load_processed.qmd >}}

## Evaluation

::: {.panel-tabset}

## .columns

```{python}
passengers_df.columns
```

## .info()

```{python}
passengers_df.info()
```

## .shape

```{python}
passengers_df.shape
```

This returns `(rows, columns`) and can be slices to get one or the other by its index. For example, the number of rows:

```{python}
passengers_df.shape[0]
```

## .dtypes

```{python}
passengers_df.dtypes
```

:::

## Modification


::: {.panel-tabset}

## .rename()

Rename columns by passing `"old_name":"new_name"` to the columns argument of `.rename()`. Remember to use `inplace=True` to store the changes in the existing DataFrame.

```{python}

passengers_df.rename(columns={
    "sibsp":"sibling_spouse_count",
    "parch":"parents_children_count"
}, inplace=True)

passengers_df.columns

```


## pd.Categorical()

Define categorical ordering by passing desired label ordering into `pd.Categorical`.

```{python}

desired_ordering = ["First", "Second", "Third"]

passengers_df["class"] = pd.Categorical(
    passengers_df["class"],
    categories=desired_ordering,
    ordered=True
)

passengers_df.info()

```

Calling the variable shows that it looks the same as before, but now pandas knows the correct ordering `['First' < 'Second' < 'Third']`.

```{python}
passengers_df["class"]
```

Defining the variable as an ordered categorical series stores a numeric representation of the data labels.

```{python}
passengers_df["class"].cat.codes
```

These can be accessed for further analysis, if desired.

```{python}
passengers_df["class"].cat.codes.median()
```

:::

## Summarization

::: {.panel-tabset}

## .describe()

```{python}

passengers_df.describe()

```

## .describe(include=["object", "category"])

```{python}

passengers_df.describe(include=["object", "category"])

```

## .nunique()

Return the number of unique values for each variable in the dataset.

```{python}

passengers_df.nunique()

```

:::

## Subsetting


::: {.panel-tabset}

## Boolean Index

Works by first checking if a column meets some condition (True/False). It filters the original dataset for those with `True`.

```{python}

passengers_df[passengers_df["age"] > 50]

```

You can also multiple criteria using parentheses for each 

```{python}

passengers_df[(passengers_df["age"] > 50) & (passengers_df["sex"] == "female")]

```

## .query()

```{python}

passengers_df.query("age > 50")

```

Multiple conditions can go in the same statement.

```{python}

passengers_df.query("age > 50 and sex == 'female'")


```

## .iloc[]

Use `.iloc[row(s), column(s)]` to return index-based results.

For example, the first row:

```{python}
# return first row from the top of the dataset
passengers_df.iloc[0]

```

Or get the first row, along with only the first three columns.

```{python}
# return first row from the top of the dataset
passengers_df.iloc[0, 0:4]

```

## .loc[]

Use `iloc[row(s), column(s)]` to return label-based results.

Let's use the output from `.describe()` for the whole dataset.


```{python}
summary_data = passengers_df.describe()
```

Return the count for all columns.

```{python}

summary_data.loc["count"]
```

Return the mean for fare and age.

```{python}

summary_data.loc["mean", ["fare", "age"]]

```

:::



{{< include _save_processed.qmd >}}