# Analyzing One Variable  {.unnumbered}

{{< include _load_processed.qmd >}}

You can get to a specific variable in your DataFrame in two ways:

1. Bracket notation: `passengers_df["embark_town"]` 
2. Dot notation: `passengers_df.embark_town`

Dot notation is often quicker, especially if your variable names are well constructed. However, be aware that if the variable name is the same as a reserved name in Python (e.g., `class`) or pandas, that you might hit errors.

## Categorical

```{python}

passengers_df["embark_town"]

```

### Value Counts

::: {.panel-tabset}

## .value_counts()

```{python}

passengers_df["embark_town"].value_counts()

```

## sort

Value counts are sorted by frequency (top to bottom) by default. You can turn this off with `sort`.

```{python}

passengers_df["embark_town"].value_counts(sort = False)

```

You can also use `ascending` to change the sort order.

```{python}

passengers_df["embark_town"].value_counts(sort = True, ascending=True)

```

## normalize

The `normalize` argument returns relative frequencies, which is the percent of total observations.

```{python}

passengers_df["embark_town"].value_counts(normalize = True)

```

:::

### Visualization

::: {.panel-tabset}

## .plot.bar()

```{python}
passengers_df["embark_town"].value_counts().plot.bar()
```

## .plot.barh()

```{python}
passengers_df["embark_town"].value_counts().plot.barh()
```

## .plot.pie()

Although it is generally better to avoid pie charts, using them with few data points and clear labels can be ok. 

```{python}
passengers_df["embark_town"].value_counts().plot.pie()
```

:::

### String Methods

Because categorical variables have data labels that are strings, we can use a lot of the built-in Python functionality to extract additional information from them.

For example:

::: {.panel-tabset}

## str.len()

```{python}

passengers_df["embark_town"].str.len()

```

## str.upper()

```{python}
passengers_df["embark_town"].str.upper()

```

## .str[]

Get partial text by slicing. For example, the first three characters.

```{python}
passengers_df["embark_town"].str[0:3]
```

:::


### Other

::: {.panel-tabset}

## .nunique()

Return the number of unique data labels

```{python}

passengers_df["embark_town"].nunique()

```


:::

## Numeric

```{python}

passengers_df["age"]

```

### Summary and Subsetting

::: {.panel-tabset}

## .describe

```{python}
passengers_df["age"].describe()
```

## .nlargest()

```{python}
passengers_df["age"].nlargest()
```

## .nsmallest()

```{python}
passengers_df["age"].nsmallest()
```

## math methods

```{python}
passengers_df["age"].mean()
```

:::

### Rank

Add a rank for each value relative to all observations. The method defaults to `ascending=False`, but this can be changed to `True` when you want lower values to earn higher ranks.

::: {.panel-tabset}

## average

Ties get the average of their rank positions (default)

```{python}
passengers_df["age"].rank(method = "average").sort_values()
```

## min

Ties all get the lowest possible rank

```{python}
passengers_df["age"].rank(method="min").sort_values()
```

## max

Ties all get the highest possible rank

```{python}
passengers_df["age"].rank(method="max").sort_values()
```

## first

Ties ranked by order they appear in data

```{python}
passengers_df["age"].rank(method="first").sort_values()
```

## dense

Like min, but no gaps created in ranking sequence

```{python}
passengers_df["age"].rank(method="dense").sort_values()
```

:::

### Visualization

::: {.panel-tabset}

## .plot.hist()

```{python}
passengers_df["age"].plot.hist()
```

## .plot.hist(bins=)

```{python}
passengers_df["age"].plot.hist(bins=80)
```

## .plot.box()

```{python}
passengers_df["age"].plot.box()
```

:::

### Binning into categories

Sometimes you want to break a numeric variable into a set of defined categories or bucketed ranges. For example, instead of analyzing the raw numeric data for `fare` you might want to group those into buckets to show the distribution in a different way.


::: {.panel-tabset}

## You choose the bins

Let's say you want to define the following binning based on your understanding of the data.

1. Zero to 20 
2. 20 to 50
3. 50 to 100
4. More than 100

First we need to define bins and their associated labels.

```{python}
bins = [0, 20, 50, 100, float('inf')]
labels = ['0-20', '20-50', '50-100', 'more than 100']
```

Next, we need to apply this information to the dataframe.

```{python}
passengers_df['fare_range'] = pd.cut(passengers_df['fare'], 
                         bins=bins, 
                         labels=labels, 
                         right=False,
                         ordered=True
                         )
```

Then we can call the variables and see which data was assigned to which bucket.

```{python}

passengers_df[["passenger_id", "fare", "fare_range"]]

```

Let's check the data type of the new variable.

```{python}
passengers_df["fare_range"].info()
```

And then make frequency counts to see the distribution.

```{python}

passengers_df["fare_range"].value_counts()
```

## Auto binning

```{python}

(
passengers_df["fare"],
pd.cut(passengers_df["fare"], bins=5)
)
```

:::





{{< include _save_processed.qmd >}}
