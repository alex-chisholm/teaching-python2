# General Overview  {.unnumbered}

# Getting Started

Before we dive into data analytics in Python, let's recap Python basics using just the standard library. This guide serves as a comprehensive reference for Python fundamentals that you'll use in data analysis.

# Variables

Variables store data that can be used throughout your program. Python automatically determines the data type based on the value you assign.

## Strings

Text data is stored as strings and enclosed in quotes.

::: {.panel-tabset}

## Basic String Operations

```{python}
country = "Netherlands"
print(country)
print(f"Type: {type(country)}")
print(f"Length: {len(country)}")
```

## Case Methods

```{python}
country = "Netherlands"
city = "den haag"

print(f"Upper: {country.upper()}")
print(f"Lower: {country.lower()}")
print(f"Title: {city.title()}")
print(f"Capitalize: {city.capitalize()}")
```

## String Testing

```{python}
country = "Netherlands"

print(f"Starts with 'Neth': {country.startswith('Neth')}")
print(f"Ends with 'lands': {country.endswith('lands')}")
print(f"Is alphabetic: {country.isalpha()}")
print(f"Is digit: {country.isdigit()}")
```

:::

## Numbers (Integers and Floats)

> Note: Integers (whole numbers) and Floats (decimals) have nearly identical treatment in Python.

::: {.panel-tabset}

## Basic Numbers

```{python}
gdp_capita = 50000
gdp_capita_float = 50000.00

print(f"Integer: {gdp_capita} (type: {type(gdp_capita)})")
print(f"Float: {gdp_capita_float} (type: {type(gdp_capita_float)})")
print(f"Equal? {gdp_capita == gdp_capita_float}")
```

## Basic Math

```{python}
gdp_capita = 50000

print(f"Addition: {gdp_capita + 5000}")
print(f"Subtraction: {gdp_capita - 5000}")
print(f"Multiplication: {gdp_capita * 2}")
print(f"Division: {gdp_capita / 1000}")
print(f"Floor division: {gdp_capita // 1000}")
print(f"Modulo: {gdp_capita % 1000}")
print(f"Exponentiation: {gdp_capita ** 2}")
```

## Built-in Functions

```{python}
gdp_capita = 50000

print(f"Absolute value: {abs(gdp_capita)}")
print(f"Round to nearest thousand: {round(gdp_capita, -3)}")
print(f"Minimum: {min(gdp_capita, 60000)}")
print(f"Maximum: {max(gdp_capita, 40000)}")
print(f"Sum: {sum([gdp_capita, 45000, 55000])}")
```

## Math Module

```{python}
import math
gdp_capita = 50000

print(f"Square root: {math.sqrt(gdp_capita):.1f}")
print(f"Log base 10: {math.log10(gdp_capita):.3f}")
print(f"Ceiling division: {math.ceil(gdp_capita/3)}")
```

## Type Conversion

```{python}
gdp_capita = 50000

print(f"To string: '{str(gdp_capita)}'")
print(f"To float: {float(gdp_capita)}")
print(f"Number of digits: {len(str(gdp_capita))}")
```

:::

## Booleans

Boolean values represent True or False and are essential for conditional logic and data filtering.

::: {.panel-tabset}

## Basic Booleans

```{python}
is_european = True
is_landlocked = False

print(f"European: {is_european}")
print(f"Type: {type(is_european)}")
```

## Boolean Operations

```{python}
is_european = True
is_landlocked = False

print(f"Both conditions: {is_european and is_landlocked}")
print(f"Either condition: {is_european or is_landlocked}")
print(f"Not European: {not is_european}")
```

:::

## Null values

::: {.panel-tabset}

## Basic None

```{python}
my_null = None
print(f"Type: {type(my_null)}")
```

## None Checking

```{python}
my_null = None

if my_null is None:
    print("Value is None")

# Using None in comparisons
values = [1, 2, None, 4, 5]
clean_values = [x for x in values if x is not None]
print(f"Clean values: {clean_values}")
```

:::

# Lists

Lists are ordered collections that can store multiple items of any data type.

::: {.panel-tabset}

## Creating Lists

```{python}
# Empty list
countries = []

# List with initial values
european_countries = ['Netherlands', 'France', 'Germany', 'Spain']
print(european_countries)

# Mixed data types
mixed_list = ['Netherlands', 50000, True, None]
print(mixed_list)
```

## Adding Items

```{python}
countries = ['Netherlands', 'France']

countries.append('Germany')  # Add to end
print(f"After append: {countries}")

countries.insert(1, 'Belgium')  # Insert at specific position
print(f"After insert: {countries}")

countries.extend(['Spain', 'Italy'])  # Add multiple items
print(f"After extend: {countries}")
```

## Accessing Items

```{python}
countries = ['Netherlands', 'Belgium', 'France', 'Germany', 'Spain', 'Italy']

print(f"First item: {countries[0]}")
print(f"Last item: {countries[-1]}")
print(f"Slice [1:3]: {countries[1:3]}")
print(f"First three: {countries[:3]}")
print(f"Last two: {countries[-2:]}")
```

## Modifying & Removing

```{python}
countries = ['Netherlands', 'Belgium', 'France', 'Germany']

countries[0] = 'Holland'  # Replace item
print(f"After replace: {countries}")

countries.remove('Belgium')  # Remove first occurrence
print(f"After remove: {countries}")

popped = countries.pop()  # Remove and return last item
print(f"Removed: {popped}")
print(f"After pop: {countries}")
```

## List Functions & Methods

```{python}
numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# Built-in functions
print(f"Length: {len(numbers)}")
print(f"Sum: {sum(numbers)}")
print(f"Min: {min(numbers)}")
print(f"Max: {max(numbers)}")

# List methods
print(f"Count of 1: {numbers.count(1)}")
print(f"Index of 4: {numbers.index(4)}")

numbers_copy = numbers.copy()
numbers_copy.sort()  # Sort in place
print(f"Sorted: {numbers_copy}")

numbers_copy.reverse()  # Reverse in place
print(f"Reversed: {numbers_copy}")
```

## List Comprehensions

```{python}
# Create a list of squares
squares = [x**2 for x in range(1, 6)]
print(f"Squares: {squares}")

# Filter and transform
words = ['apple', 'banana', 'cherry', 'date']
long_words = [word.upper() for word in words if len(word) > 5]
print(f"Long words: {long_words}")

# More complex example
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_squares = [x**2 for x in numbers if x % 2 == 0]
print(f"Even squares: {even_squares}")
```

:::

# Tuples

Tuples are ordered collections like lists, but they are **immutable** (cannot be changed after creation).

::: {.panel-tabset}

## Basic Tuples

```{python}
# Create a tuple
coordinates = (52.3676, 4.9041)  # Amsterdam coordinates
print(f"Amsterdam coordinates: {coordinates}")
print(f"Type: {type(coordinates)}")

# Access tuple elements (same as lists)
latitude = coordinates[0]
longitude = coordinates[1]
print(f"Latitude: {latitude}, Longitude: {longitude}")
```

## Tuple Unpacking

```{python}
coordinates = (52.3676, 4.9041)

# Tuple unpacking (very useful for data analytics)
lat, lon = coordinates
print(f"Unpacked - Lat: {lat}, Lon: {lon}")

# Multiple assignment
country_info = ("Netherlands", 17_441_000, "Euro", True)
name, population, currency, eu_member = country_info
print(f"{name} has {population:,} people, uses {currency}, EU member: {eu_member}")
```

## Tuple Operations

```{python}
country_info = ("Netherlands", 17_441_000, "Euro", True)

print(f"Length: {len(country_info)}")
print(f"Index of 'Euro': {country_info.index('Euro')}")
print(f"Count of True: {country_info.count(True)}")

# Tuples are immutable - this would cause an error:
# country_info[0] = "Holland"  # TypeError!
```

:::

# Sets

Sets are unordered collections of **unique** items. They're excellent for removing duplicates and set operations.

::: {.panel-tabset}

## Creating Sets

```{python}
# Create sets
european_countries = {"Netherlands", "France", "Germany", "Spain", "Italy"}
nordic_countries = {"Norway", "Sweden", "Denmark", "Finland", "Iceland"}

print(f"European countries: {european_countries}")
print(f"Type: {type(european_countries)}")
```

## Remove Duplicates

```{python}
# Remove duplicates from a list
cities_with_duplicates = ["Amsterdam", "Paris", "Berlin", "Amsterdam", "Madrid", "Paris"]
unique_cities = set(cities_with_duplicates)
print(f"Unique cities: {unique_cities}")

# Convert back to list if needed
unique_cities_list = list(unique_cities)
print(f"As list: {unique_cities_list}")
```

## Set Operations

```{python}
eu_countries = {"Netherlands", "France", "Germany", "Spain", "Italy", "Sweden", "Denmark", "Finland"}
rich_countries = {"Netherlands", "Germany", "Norway", "Sweden", "Denmark", "Switzerland"}

# Intersection: countries that are both EU and rich
eu_and_rich = eu_countries & rich_countries
print(f"EU and rich: {eu_and_rich}")

# Union: all countries (no duplicates)
all_countries = eu_countries | rich_countries
print(f"All countries: {all_countries}")

# Difference: EU countries that are not in rich countries
eu_not_rich = eu_countries - rich_countries
print(f"EU but not rich: {eu_not_rich}")
```

## Modifying Sets

```{python}
my_countries = {"Netherlands", "France"}

my_countries.add("Germany")
print(f"After adding: {my_countries}")

my_countries.remove("France")  # Will error if not found
print(f"After removing: {my_countries}")

my_countries.discard("Spain")  # Won't error if not found
print(f"After discarding non-existent: {my_countries}")
```

:::

# Dictionaries

Dictionaries store key-value pairs and are essential for structured data.

::: {.panel-tabset}

## Basic Operations

```{python}
currencies = {
    'US': 'Dollar',
    'NL': 'Euro',
    'JP': 'Yen'
}

print(f"Currencies: {currencies}")
print(f"US Currency: {currencies['US']}")

# Add a new item
currencies['MX'] = 'Peso'
print(f"After adding: {currencies}")

# Delete an item
del currencies['MX']
print(f"After deleting: {currencies}")
```

## Safe Access Methods

```{python}
currencies = {'US': 'Dollar', 'NL': 'Euro', 'JP': 'Yen'}

# Get method (returns None if key doesn't exist)
print(f"US Currency: {currencies.get('US')}")
print(f"Brazil Currency: {currencies.get('BR')}")  # Returns None

# Get with default value
print(f"Unknown Currency: {currencies.get('ZZ', 'Not in our dictionary')}")
```

## Dictionary Views

```{python}
currencies = {'US': 'Dollar', 'NL': 'Euro', 'JP': 'Yen'}

print(f"Keys: {list(currencies.keys())}")
print(f"Values: {list(currencies.values())}")
print(f"Items: {list(currencies.items())}")
```

## Dictionary Loops

```{python}
currencies = {'US': 'Dollar', 'NL': 'Euro', 'JP': 'Yen'}

print("Loop through keys:")
for country in currencies:
    print(f"  {country}")

print("\nLoop through values:")
for currency in currencies.values():
    print(f"  {currency}")

print("\nLoop through both:")
for country, currency in currencies.items():
    print(f"  The currency of {country} is the {currency}")
```

## Complex Dictionaries

```{python}
# List of dictionaries
countries = []

netherlands = {
    'capital': 'Amsterdam',
    'region': 'Western Europe'
}

france = {
    'capital': 'Paris',
    'region': 'Western Europe'
}

countries.append(netherlands)
countries.append(france)

print("Countries list:")
for country in countries:
    display_name = f"{country['capital']}, {country['region']}"
    print(f"  {display_name}")
```

## Nested Structures

```{python}
# Dictionaries with lists
languages = {
    'Canada': ['English', 'French'],
    'Belgium': ['French', 'Dutch'],
    'Switzerland': ['German', 'Italian', 'French']
}

for country, languages_list in languages.items():
    print(f"In {country}, the following languages are spoken:")
    for language in languages_list:
        print(f"  • {language}")
```

:::

# Data Structure Comparison

Understanding when to use each data structure is crucial for efficient data analysis.

| Data Structure | Ordered | Mutable | Duplicates | Use Case |
|----------------|---------|---------|------------|----------|
| **List** | ✓ | ✓ | ✓ | Sequential data, multiple values of same type |
| **Tuple** | ✓ | ✗ | ✓ | Fixed data records, function returns |
| **Set** | ✗ | ✓ | ✗ | Unique values, set operations |
| **Dictionary** | ✓ | ✓ | ✗ (keys) | Key-value mappings, structured data |

::: {.panel-tabset}

## Example Usage

```{python}
# List: Multiple test scores for one student
test_scores = [85, 92, 78, 96, 88]
print(f"Average score: {sum(test_scores) / len(test_scores):.1f}")

# Tuple: Student information that shouldn't change
student_info = ("Alice Johnson", 20, "Computer Science")
name, age, major = student_info

# Set: Unique skills
skills = {"Python", "SQL", "Excel", "Python", "Statistics"}  # Duplicate Python removed
print(f"Skills: {skills}")

# Dictionary: Complete student profile
student_profile = {
    "name": "Alice Johnson",
    "age": 20,
    "major": "Computer Science",
    "test_scores": [85, 92, 78, 96, 88],
    "skills": ["Python", "SQL", "Excel", "Statistics"]
}

print(f"Student: {student_profile['name']} ({student_profile['major']})")
print(f"Skills: {', '.join(student_profile['skills'])}")
```

## Performance Comparison

```{python}
import time

# Create large datasets
large_list = list(range(10000))
large_set = set(range(10000))
large_dict = {i: f"value_{i}" for i in range(10000)}

# Performance comparison for lookups
target = 9999

# List lookup (slow for large lists)
start_time = time.time()
found = target in large_list
list_time = time.time() - start_time

# Set lookup (very fast)
start_time = time.time()
found = target in large_set
set_time = time.time() - start_time

# Dictionary lookup (very fast)
start_time = time.time()
found = target in large_dict
dict_time = time.time() - start_time

print(f"List lookup: {list_time:.6f} seconds")
print(f"Set lookup: {set_time:.6f} seconds") 
print(f"Dict lookup: {dict_time:.6f} seconds")
if set_time > 0:
    print(f"Set is {list_time/set_time:.0f}x faster than list for lookups")
```

:::

# Conditional Statements

Control your program based on certain logical conditions.

## Operators Reference

| Operator | Description | Example | Result |
|----------|-------------|---------|---------|
| `==` | Equal to | `5 == 5` | `True` |
| `!=` | Not equal to | `5 != 3` | `True` |
| `<` | Less than | `3 < 5` | `True` |
| `>` | Greater than | `7 > 4` | `True` |
| `<=` | Less than or equal to | `5 <= 5` | `True` |
| `>=` | Greater than or equal to | `6 >= 4` | `True` |
| `in` | Membership test | `'a' in 'cat'` | `True` |
| `not in` | Negative membership test | `'x' not in 'cat'` | `True` |
| `is` | Identity test | `x is None` | `True` (if x is None) |
| `is not` | Negative identity test | `x is not None` | `True` (if x is not None) |
| `and` | Logical AND | `True and False` | `False` |
| `or` | Logical OR | `True or False` | `True` |
| `not` | Logical NOT | `not True` | `False` |

::: {.panel-tabset}

## Basic If Statements

```{python}
monthly_spend = 6000 
monthly_budget = 5000

if monthly_spend > monthly_budget:
    print("Careful, you're spending more than you are earning!")

# Store the outcome as a variable
losing_money = monthly_spend > monthly_budget
print(f"Losing money? {losing_money}")

if losing_money:
    print("Careful, you are losing money")
```

## If-Else Statements

```{python}
monthly_spend = 4000
monthly_budget = 5000

if monthly_spend > monthly_budget:
    guidance = "Stop spending money you don't have"
else:
    guidance = "You're doing alright. Keep it up!"

print(guidance)
```

## If-Elif-Else

```{python}
monthly_spend = 10000
monthly_budget = 10000

if monthly_spend > monthly_budget:
    guidance = "Stop spending money you don't have"
elif monthly_spend < monthly_budget:
    guidance = "You're doing alright. Keep it up!"
else:
    guidance = "Money in, money out!"

print(guidance)
```

## Ternary Operator

```{python}
monthly_spend = 6000
monthly_budget = 5000

# Ternary operator (conditional expression)
losing_money = True if monthly_spend > monthly_budget else False
print(f"Losing money? {losing_money}")

# More practical example
status = "Over budget" if monthly_spend > monthly_budget else "Within budget"
print(f"Budget status: {status}")
```

:::

# Loops

Loops allow you to repeat code efficiently. There are two main types of loops in Python.

::: {.panel-tabset}

## For Loops - Basics

```{python}
# Loop through a list
countries = ['Netherlands', 'France', 'Germany', 'Spain']
for country in countries:
    print(f"Visiting {country}")
```

## For Loops - With Index

```{python}
countries = ['Netherlands', 'France', 'Germany', 'Spain']

# Loop with enumerate to get index and value
for index, country in enumerate(countries):
    print(f"{index + 1}. {country}")

# Starting enumerate at 1
for number, country in enumerate(countries, 1):
    print(f"{number}. {country}")
```

## For Loops - Ranges

```{python}
# Loop through a range of numbers
print("Basic range:")
for i in range(5):
    print(f"Number: {i}")

print("\nRange with start, stop, step:")
for i in range(2, 10, 2):  # Start at 2, stop before 10, step by 2
    print(f"Even number: {i}")

print("\nLoop through string characters:")
for letter in "Python":
    print(f"Letter: {letter}")
```

## While Loops

```{python}
# While loops continue as long as a condition is True
month = 1
while month <= 12:
    print(f"Month {month}")
    month += 1
```

## Loop Control

```{python}
# Using break
print("Using break:")
for i in range(10):
    if i == 5:
        print("Breaking at 5")
        break
    print(i)

print("\nUsing continue:")
for i in range(5):
    if i == 2:
        print("Skipping 2")
        continue
    print(f"Processing {i}")
```

## Practical Example

```{python}
# Processing data with conditions
sales_data = [100, 0, 250, -50, 300, 0, 150]
valid_sales = []

for sale in sales_data:
    if sale < 0:
        print(f"Invalid sale amount: {sale}")
        continue
    if sale == 0:
        print("No sale recorded")
        continue
    valid_sales.append(sale)
    
print(f"Valid sales: {valid_sales}")
print(f"Total valid sales: {sum(valid_sales)}")
```

:::

# Functions

Build once, reuse whenever. Functions are the building blocks of organized, reusable code.

::: {.panel-tabset}

## Basic Functions

```{python}
def two_plus_two():
    """return the sum of two plus two""" # docstring: standard place to describe a function
    return 2+2

result = two_plus_two()
print(f"Result: {result}")
```

## Functions with Parameters

```{python}
def add_numbers(num1, num2):
    """return the sum of num1 and num2"""
    return num1 + num2

# Positional arguments
print(f"Positional: {add_numbers(2, 2)}")

# Keyword arguments
print(f"Keyword: {add_numbers(num1=10, num2=2)}")

# Mixed (positional must come first)
print(f"Mixed: {add_numbers(5, num2=3)}")
```

## Error Handling in Functions

```{python}
def add_numbers_safe(num1, num2):
    """Return the sum of num1 and num2 with error handling"""
    try:
        # Convert inputs to float to handle both integers and decimals
        number1 = float(num1)
        number2 = float(num2)
        
        return number1 + number2
        
    except ValueError:
        print("Error: Please enter valid numbers only.")
        return None
    except TypeError:
        print("Error: Invalid input type. Please provide numeric values.")
        return None

# Test the function
print(f"Valid: {add_numbers_safe(5, 3)}")
print(f"Invalid: {add_numbers_safe('car', 'bike')}")
print(f"None input: {add_numbers_safe(None, 3)}")
```

## Arbitrary Arguments (*args)

```{python}
def family(last_name, *first_names):
    """Return all people within a family"""
    print(f"{last_name}:")
    for first_name in first_names:
        print(f"* {first_name}")

family("chisholm", "alex", "karen", "clara", "gracie")
```

## Keyword Arguments (**kwargs)

```{python}
def country(name, **qualities):
    """Display country with its qualities"""
    print(f"{name}:")
    for key, value in qualities.items():
        print(f"* {key}: {value}")

print("Netherlands only:")
country("Netherlands")

print("\nNetherlands with qualities:")
country("Netherlands", region="Europe", climate="Wet", landlocked=False)
```

## Default Parameters

```{python}
def hello(name, greeting="Hello"):
    """Return a greeting message"""
    return f"{greeting}, {name}!"

# Using default greeting
print(hello("Tommy"))

# Custom greeting
print(hello("Tommy", "What's going on"))

# Mix of defaults and custom
def describe_country(name, population="Unknown", continent="Unknown"):
    return f"{name} is in {continent} with {population} people"

print(describe_country("Netherlands", population="17.4 million"))
print(describe_country("Mystery Country"))
```

:::

## Return vs. Print

Understanding the difference between `return` and `print` is crucial for writing reusable functions.

::: {.panel-tabset}

## Return Functions

```{python}
def calculate_area(length, width):
    """Calculate rectangle area - returns a value"""
    return length * width

# Function with return - value can be stored
stored_area = calculate_area(5, 3)
print(f"Stored area: {stored_area}")
print(f"Type: {type(stored_area)}")

# Return values can be used in calculations
area1 = calculate_area(5, 3)
area2 = calculate_area(4, 6)
total_area = area1 + area2
print(f"Total area: {total_area}")
```

## Print Functions

```{python}
def display_area(length, width):
    """Calculate and display rectangle area - prints but doesn't return"""
    area = length * width
    print(f"The area is {area} square units")

# Function with print - returns None
printed_result = display_area(5, 3)
print(f"Printed result: {printed_result}")
print(f"Type: {type(printed_result)}")

# Print functions cannot be used in calculations
# This would cause an error: total = display_area(5, 3) + display_area(4, 6)
```

:::

# Modules and Imports

Modules allow you to organize code across multiple files and reuse functionality.

::: {.panel-tabset}

## Built-in Modules

```{python}
# Different ways to import
import math
import random
from datetime import datetime
import json

# Using imported modules
print(f"Pi: {math.pi}")
print(f"Random number: {random.randint(1, 100)}")
print(f"Current time: {datetime.now()}")

data = {"name": "Alice", "score": 95}
json_string = json.dumps(data)
print(f"JSON: {json_string}")
```

## Import Variations

```{python}
# Import specific functions
from math import sqrt, pow
result = sqrt(pow(3, 2) + pow(4, 2))  # Pythagorean theorem
print(f"Hypotenuse: {result}")

# Import with alias
import statistics as stats
scores = [85, 92, 78, 96, 88]
print(f"Mean: {stats.mean(scores)}")
print(f"Median: {stats.median(scores)}")
print(f"Standard deviation: {stats.stdev(scores):.2f}")
```

## Custom Module Example

```{python}
# Example: Functions you might save in 'data_helpers.py':
def clean_data(data_list):
    """Remove None values and convert to numbers"""
    cleaned = []
    for item in data_list:
        if item is not None:
            try:
                cleaned.append(float(item))
            except (ValueError, TypeError):
                pass
    return cleaned

def calculate_stats(numbers):
    """Calculate basic statistics"""
    if not numbers:
        return {"mean": 0, "min": 0, "max": 0}
    
    return {
        "mean": sum(numbers) / len(numbers),
        "min": min(numbers),
        "max": max(numbers)
    }

# Using the functions:
raw_data = [1, "2", None, 3.5, "invalid", 4]
clean_numbers = clean_data(raw_data)
stats = calculate_stats(clean_numbers)
print(f"Clean data: {clean_numbers}")
print(f"Statistics: {stats}")
```

:::

# Classes

A class is like a blueprint or template for a specific concept or entity.

::: {.panel-tabset}

## Basic Class Definition

```{python}
class Stock:
    def __init__(self, symbol, price):
        """Create a stock with symbol and price"""
        self.symbol = symbol
        self.price = price

# Create a class instance
apple = Stock("APPL", 214)
print(f"Symbol: {apple.symbol}, Price: ${apple.price}")
```

## Adding Methods

```{python}
class Stock:
    def __init__(self, symbol, price):
        """Create a stock with symbol and price"""
        self.symbol = symbol
        self.price = price
    
    def display(self):
        """Show the stock info"""
        print(f"The most recent stock price for {self.symbol} is ${self.price}.")
    
    def too_expensive(self):
        """Check if stock costs more than $100"""
        return self.price > 100

# Create instances and use methods
apple = Stock("APPL", 214)
apple.display()
print(f"Too expensive? {apple.too_expensive()}")

uber = Stock("UBER", 91)
uber.display()
print(f"Too expensive? {uber.too_expensive()}")
```

## More Complex Methods

```{python}
class Stock:
    def __init__(self, symbol, price):
        self.symbol = symbol
        self.price = price
        self.history = [price]  # Track price history
    
    def update_price(self, new_price):
        """Update stock price and add to history"""
        self.price = new_price
        self.history.append(new_price)
    
    def price_change(self):
        """Calculate change from first recorded price"""
        if len(self.history) > 1:
            return self.price - self.history[0]
        return 0
    
    def performance_summary(self):
        """Return a summary of stock performance"""
        change = self.price_change()
        status = "up" if change > 0 else "down" if change < 0 else "unchanged"
        return f"{self.symbol} is {status} by ${abs(change):.2f}"

# Example usage
tesla = Stock("TSLA", 200)
tesla.update_price(220)
tesla.update_price(190)
print(f"Current price: ${tesla.price}")
print(f"Price history: {tesla.history}")
print(tesla.performance_summary())
```

:::

# File Input/Output

Working with files is essential for data analytics. Python provides built-in functions to read and write different file types.

::: {.panel-tabset}

## Writing Text Files

```{python}
# Writing to a file (creates new file or overwrites existing)
countries_data = ['Netherlands', 'France', 'Germany', 'Spain']

with open('countries.txt', 'w') as file:
    for country in countries_data:
        file.write(f"{country}\n")

print("Countries written to file")

# Appending to a file
with open('countries.txt', 'a') as file:
    file.write("Italy\n")
    file.write("Portugal\n")

print("Additional countries appended")
```

## Reading Text Files

```{python}
# Reading entire file content
try:
    with open('countries.txt', 'r') as file:
        content = file.read()
        print("File content:")
        print(content)
except FileNotFoundError:
    print("File not found")

# Reading line by line (memory efficient for large files)
try:
    with open('countries.txt', 'r') as file:
        print("Line by line:")
        for line_number, line in enumerate(file, 1):
            print(f"Line {line_number}: {line.strip()}")
except FileNotFoundError:
    print("File not found")
```

## Reading into Lists

```{python}
# Reading all lines into a list
try:
    with open('countries.txt', 'r') as file:
        lines = file.readlines()
        print(f"Read {len(lines)} lines")
        clean_lines = [line.strip() for line in lines]  # Remove newlines
        print(f"Countries: {clean_lines}")
except FileNotFoundError:
    print("File not found")
```

:::

## Working with CSV Files

CSV (Comma-Separated Values) files are common in data analytics.

::: {.panel-tabset}

## Writing CSV

```{python}
import csv

# Writing CSV data
sales_data = [
    ['Date', 'Product', 'Sales'],
    ['2024-01-01', 'Widget A', 100],
    ['2024-01-02', 'Widget B', 150],
    ['2024-01-03', 'Widget A', 120]
]

with open('sales.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(sales_data)

print("CSV file created")
```

## Reading CSV - Basic

```{python}
import csv

# Reading CSV data
try:
    with open('sales.csv', 'r') as file:
        reader = csv.reader(file)
        header = next(reader)  # Get header row
        print(f"Headers: {header}")
        
        for row in reader:
            print(f"Date: {row[0]}, Product: {row[1]}, Sales: {row[2]}")
except FileNotFoundError:
    print("CSV file not found")
```

## Reading CSV - as Dictionaries

```{python}
import csv

# Reading CSV as dictionaries (more convenient)
try:
    with open('sales.csv', 'r') as file:
        reader = csv.DictReader(file)
        for row in reader:
            print(f"On {row['Date']}, {row['Product']} sold {row['Sales']} units")
        
        # Convert to list of dictionaries
        file.seek(0)  # Reset file pointer
        reader = csv.DictReader(file)
        data_list = list(reader)
        print(f"\nAs list: {data_list}")
except FileNotFoundError:
    print("CSV file not found")
```

:::

## Working with JSON Files

JSON (JavaScript Object Notation) is common for structured data.

::: {.panel-tabset}

## Writing JSON

```{python}
import json

# Writing JSON data
country_data = {
    "name": "Netherlands",
    "capital": "Amsterdam",
    "population": 17441000,
    "languages": ["Dutch", "English"],
    "eu_member": True
}

with open('country.json', 'w') as file:
    json.dump(country_data, file, indent=2)

print("JSON file created")
```

## Reading JSON

```{python}
import json

# Reading JSON data
try:
    with open('country.json', 'r') as file:
        data = json.load(file)
        print(f"Country: {data['name']}")
        print(f"Capital: {data['capital']}")
        print(f"Population: {data['population']:,}")
        print(f"Languages: {', '.join(data['languages'])}")
        print(f"EU Member: {data['eu_member']}")
except FileNotFoundError:
    print("JSON file not found")
except json.JSONDecodeError:
    print("Invalid JSON file")
```

## JSON String Operations

```{python}
import json

# Working with JSON strings (not files)
data_dict = {"name": "Alice", "scores": [85, 92, 78]}

# Convert dict to JSON string
json_string = json.dumps(data_dict)
print(f"JSON string: {json_string}")

# Convert JSON string back to dict
parsed_data = json.loads(json_string)
print(f"Parsed data: {parsed_data}")
print(f"Name: {parsed_data['name']}")
```

:::

## File Path Operations

::: {.panel-tabset}

## File Existence & Info

```{python}
import os

# Check if file exists
if os.path.exists('countries.txt'):
    print("File exists")
    print(f"File size: {os.path.getsize('countries.txt')} bytes")
else:
    print("File does not exist")

# Get file information
try:
    stat_info = os.stat('countries.txt')
    print(f"Last modified timestamp: {stat_info.st_mtime}")
except FileNotFoundError:
    print("File not found for stat")
```

## Directory Operations

```{python}
import os

# Working with directories
current_dir = os.getcwd()
print(f"Current directory: {current_dir}")

# List files in directory
files = os.listdir('.')
print(f"Files in current directory: {files[:5]}")  # Show first 5

# Create directory
os.makedirs('data_files', exist_ok=True)  # exist_ok prevents error if exists
print("Directory created or already exists")

# Check if it's a file or directory
for item in os.listdir('.')[:3]:  # Check first 3 items
    if os.path.isfile(item):
        print(f"{item} is a file")
    elif os.path.isdir(item):
        print(f"{item} is a directory")
```

:::

# Error Handling

Proper error handling is crucial when working with data, as files may be missing, corrupted, or in unexpected formats.

::: {.panel-tabset}

## Basic Try-Except

```{python}
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        return None
    except TypeError:
        print("Error: Both arguments must be numbers")
        return None

# Test the function
print(f"Valid division: {safe_divide(10, 2)}")
print(f"Division by zero: {safe_divide(10, 0)}")
print(f"Invalid types: {safe_divide('10', 2)}")
```

## Multiple Exception Types

```{python}
import json

def process_data_file(filename):
    try:
        with open(filename, 'r') as file:
            data = json.load(file)
            return data['values']
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return []
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in file - {e}")
        return []
    except KeyError as e:
        print(f"Error: Missing key {e} in JSON data")
        return []
    except Exception as e:
        print(f"Unexpected error: {e}")
        return []

# Test with different scenarios
result = process_data_file('nonexistent.json')
print(f"Result: {result}")
```

## Custom Exceptions

```{python}
class DataValidationError(Exception):
    """Custom exception for data validation errors"""
    pass

def validate_age(age):
    try:
        age_int = int(age)
        if age_int < 0:
            raise DataValidationError("Age cannot be negative")
        if age_int > 150:
            raise DataValidationError("Age seems unrealistic (>150)")
        return age_int
    except ValueError:
        raise DataValidationError(f"'{age}' is not a valid age")

# Test data validation
test_ages = [25, -5, "thirty", 200, "25"]
for age in test_ages:
    try:
        valid_age = validate_age(age)
        print(f"Valid age: {valid_age}")
    except DataValidationError as e:
        print(f"Invalid age '{age}': {e}")
```

## Finally Clause

```{python}
def process_file_with_cleanup(filename):
    file_handle = None
    try:
        file_handle = open(filename, 'r')
        content = file_handle.read()
        return content
    except FileNotFoundError:
        print(f"File {filename} not found")
        return None
    finally:
        if file_handle:
            file_handle.close()
            print("File closed in finally block")

# Better approach: using context manager (recommended)
def process_file_better(filename):
    try:
        with open(filename, 'r') as file:  # Automatically closes file
            return file.read()
    except FileNotFoundError:
        print(f"File {filename} not found")
        return None

# Test both approaches
print("Using finally clause:")
result1 = process_file_with_cleanup('test.txt')

print("\nUsing context manager:")
result2 = process_file_better('test.txt')
```

:::

# Testing

Testing ensures your code works correctly and helps prevent bugs when working with data.

::: {.panel-tabset}

## Simple Testing with Assertions

```{python}
def calculate_average(numbers):
    """Calculate the average of a list of numbers"""
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)

# Test the function
def test_calculate_average():
    # Test normal case
    assert calculate_average([1, 2, 3, 4, 5]) == 3.0
    
    # Test empty list
    assert calculate_average([]) == 0
    
    # Test single number
    assert calculate_average([10]) == 10.0
    
    # Test negative numbers
    assert calculate_average([-1, -2, -3]) == -2.0
    
    print("All tests passed!")

test_calculate_average()
```

## Testing Data Functions

```{python}
# Testing data cleaning functions
def clean_numeric_data(data):
    """Remove non-numeric values and convert to float"""
    cleaned = []
    for item in data:
        try:
            cleaned.append(float(item))
        except (ValueError, TypeError):
            continue  # Skip non-numeric values
    return cleaned

def test_clean_numeric_data():
    # Test mixed data
    mixed_data = [1, "2", "hello", 3.5, None, "4.7", True]
    result = clean_numeric_data(mixed_data)
    expected = [1.0, 2.0, 3.5, 4.7, 1.0]  # True converts to 1.0
    assert result == expected, f"Expected {expected}, got {result}"
    
    # Test empty list
    assert clean_numeric_data([]) == []
    
    # Test all invalid data
    assert clean_numeric_data(["hello", "world", None]) == []
    
    print("Data cleaning tests passed!")

test_clean_numeric_data()
```

## Testing with Expected Errors

```{python}
def divide_positive_numbers(a, b):
    """Divide two positive numbers"""
    if a <= 0 or b <= 0:
        raise ValueError("Both numbers must be positive")
    return a / b

def test_divide_positive_numbers():
    # Test normal case
    assert divide_positive_numbers(10, 2) == 5.0
    
    # Test that errors are raised as expected
    try:
        divide_positive_numbers(-1, 2)
        assert False, "Should have raised ValueError for negative number"
    except ValueError:
        pass  # This is expected
    
    try:
        divide_positive_numbers(5, 0)
        assert False, "Should have raised ValueError for zero"
    except ValueError:
        pass  # This is expected
    
    print("Error handling tests passed!")

test_divide_positive_numbers()
```

:::